\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename libadplug.info
@settitle AdPlug Core Library Manual
@c %**end of header

@include version.texi

@copying
This manual documents the AdPlug core library, version
@value{VERSION}.

Copyright @copyright{} 2002 Simon Peter <dn.tlp@@gmx.net>

@quotation
Permission is granted to copy, distribute and/or modify this
document under the terms of the GNU Free Documentation License,
Version 1.1 or any later version published by the Free Software
Foundation; with no Invariant Sections, with the Front-Cover texts
being "A GNU Manual," and with the Back-Cover Texts as in (a)
below.  A copy of the license is included in the section entitled
"GNU Free Documentation License."

(a) The FSF's Back-Cover Text is: "You have freedom to copy and
modify this GNU Manual, like GNU software.  Copies published by
the Free Software Foundation raise funds for GNU development."
@end quotation
@end copying

@titlepage
@title AdPlug Core Library Manual
@subtitle Version @value{VERSION}
@subtitle Last updated on @value{UPDATED}
@author Simon Peter

@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents

@ifnottex
@node Top
@top AdPlug core library

@insertcopying
@end ifnottex

@menu
* Introduction::                What is AdPlug?
* Basic Usage::                 Using AdPlug in your programs the easy way.
* Advanced Usage::              Using AdPlug in your programs the hard way.
* Linking::                     Linking your program with AdPlug.
* Hacking::                     How to hack around in AdPlug.
* Player development::          How to write new replayers for AdPlug.
* Protracker based players::    How to write Protracker based players.

* Copying::                     Your rights and freedoms.
* Variable Index::
@end menu

@node Introduction
@chapter Introduction

AdPlug is a free, multi-platform, hardware independent AdLib sound
player library, mainly written in C++. AdPlug plays sound data,
originally created for the AdLib (OPL2) audio board, on top of an OPL2
emulator or by using the real hardware. No OPL2 chip is required for
playback.

@node Basic Usage
@chapter Basic Usage

This chapter still needs to be written.

@node Advanced Usage
@chapter Advanced Usage

This chapter still needs to be written.

@node Linking
@chapter Linking

This chapter still needs to be written.

@node Hacking
@chapter Hacking

This chapter gives some coding guidelines for people wishing to hack
around in AdPlug. Be sure to also read the overall and system-specific
@file{INSTALL} files in the distribution's base directory to learn
more about the build systems.

@menu
* Coding Style::
* Debug Logging::
* Documentation::
@end menu

@node Coding Style
@section Coding Style
I do not really enforce any coding style guidelines (i don't adhere to any
style guidelines myself, so... ;) ), but it would be nice if you follow the
overall coding style, used throughout most of AdPlug's source files. If you
don't, that's perfectly okay, too.

Most of today's "super-intelligent" editors, like MSVC's one or GNU Emacs'
cc-mode, have their own idea of what the code has to look like, anyway. And
since most people tend to use these, there's no point in torturing them to
always having to change anything their editor thinks it knows better. ;)

@node Debug Logging
@section Debug Logging

AdPlug recently offers centralized debug log management. If you like to
implement debug logging inside your code, please follow these guidelines:

To implement debug logging, @code{#include "debug.h"} in your code
(this header is @strong{NOT} being installed with the rest of the
AdPlug header files into your standard include directory! It is only
available in AdPlug's @file{src/} subdirectory!).

@file{debug.h} is C code, so it is useable from both C and C++
sources. The only function you have to use is the
@code{LogWrite(fmt, ...)} function. @code{LogFile()} is used by AdPlug
internally. @code{LogWrite()} works exactly like @code{printf()},
instead that it writes to a logfile, rather than on the console.

Please format your log messages like this:

@itemize @bullet
@item
If your method/function is going to output a lot of debug info
(i.e. more than one line), please put a @code{LogWrite()} directly at
the beginning of your function, which looks like this:

@example
LogWrite("*** yourclass::yourmethod(@var{param1}, @var{param2}, @var{...}) ***\n");
@end example

And put the following line before every return from your function:

@example
LogWrite("--- yourclass::yourmethod ---\n");
@end example

This way, one can easily inspect the logfile and know to which
function every logfile-line belongs. The @code{***} lines mark the
start of a function, and the @code{---} lines mark the end.

Please substitute @var{param*} with the corresponding parameter values
of your function, if that is reasonable. For example, it won't help
much to log a pointer value --- just put something bogus or helpful
there, or noting (i.e. just a comma, so the logfile reader knows, to
which parameters the other values correspond). But logging the values
of passed ints or strings could be very helpful.

@item
If your method/function is going to output just one line, format the
line something like this:

@example
LogWrite("yourclass::yourmethod(@var{param1}, @var{param2}): your message\n");
@end example

You don't need the @code{***} and @code{---} beginning and end markers
then.

@item
For asynchronous threads, there is no way but to prefix any line with
the function name, because these messages will be sprayed throughout
the logfile.
@end itemize

@node Documentation
@section Documentation

AdPlug's documentation is written in ASCII textfiles and Texinfo
files. This way, one can easily convert the documentation to all types
of document formats.

If you would like to add to the existing documentation, please use the
writing style, that's already been used here.

@node Player development
@chapter Player development

Before you try to write a new player for AdPlug, be sure to also read
through the @ref{Hacking} chapter of this manual.

@menu
* Before the work::
* Main work::
@end menu

@node Before the work
@section Before the work

Your player normally consists of two files (the @file{.h} &
@file{.cpp} files) and you normally name them by the file extensions,
your player handles. For example, the HSC player consists of the files
@file{hsc.cpp} & @file{hsc.h}, because it handles @file{.hsc}
files. This is the same with your player class name. Thus, the HSC
player's class is called @code{ChscPlayer}. If any of these names
happens to be already taken for other purposes, just name your player
something else, appropriately.

@file{player.h} contains the abstract player interface. You have to
include it in your player to communicate with AdPlug. It also contains
some very helpful structures for use in your player. You don't need to
use the structs, but you have to use the methods provided by the
@code{opl} object (declared in @file{opl.h}, but automatically
included from @file{player.h}) inside the player class to do the OPL
I/O and initialization work.

@node Main work
@section Main work

All you have to do now is to inherit the @code{CPlayer} class into
your own player class and fill the abstract methods with code. You at
least have to fill in the following methods:

@example
bool load(istream &f, const char *filename);
bool update();
void rewind(unsigned int subsong);
float getrefresh();
std::string gettype();
@end example

The other methods from @code{CPlayer} just serve informational
purposes (as does @code{gettype()}, but it's required anyway) for
AdPlug's info box and needn't to be filled. It would be nice if you
fill them anyway, if that's reasonable for your player.

There's one more public method you have to define in your player
class:

@example
static CPlayer *factory(Copl *newopl);
@end example

Since it is static, it isn't already virtually defined in the
@code{CPlayer} class and you have to add it manually. This method
should return a freshly initialized object of your player class.  If
any errors occured (e.g. not enough memory), return @samp{0} instead.

Return true from your @code{load()} method, if the file was loaded
successfully, or false if it couldn't be loaded for any reason (will
mostly be wrong file type errors, since AdPlug tries its files with
any replayer, it is linked to). Your @code{update()} method will be
called with the frequency, you return from your @code{getrefresh()}
method, in Hz. Return true from @code{update()} if your module hasn't
ended yet. If it looped or ended, return false from that point, but
play further for any subsequent calls to @code{update()}. AdPlug will
rewind your player by itself, using the @code{rewind()} method, when
necessary.

AdPlug passes the number of the subsong, it wants to play next, to the
@code{rewind()} method of your player. This can be any value from
@samp{0} to the value returned by @code{getsubsongs()}. If you haven't
provided your own @code{getsubsongs()}, AdPlug will presume your
player doesn't have support for subsongs. In that case, AdPlug will
always @code{rewind(0)}. Please ignore any value passed with
@code{rewind()} that is out of spec for your player. This should
virtually never happen, but who knows...

After initializing your player, AdPlug normally first calls
@code{load()}, and then @code{getrefresh()} and @code{update()} in a
loop until something happens (i.e. the user stops playback or the song
ends). @code{rewind()} and all the informational methods can be called
anytime in between the other calls, but of course only after
@code{load()} has been called.

You can add your own constructors, destructors and methods to your
player object, as you like. AdPlug won't care in any way.

@node Protracker based players
@chapter Protracker based players

If you want to create a player for a Protracker-derivative format, the
generic Protracker player @code{CmodPlayer} that comes with AdPlug can
be of great help. It supports all standard Protracker features, plus a
good set of extensions to cope with most derivative formats.

When writing a player for a Protracker-derivative format, it is almost
always better to use and extend the @code{CmodPlayer} class, instead
of writing a whole new player.

@menu
* Features::
* Defaults::
* Protracker Loaders::
* Designing your Loader::
* Loading Patterns::
* Loading Instruments::
* Special Flags::
* Special Arpeggio::
@end menu

@node Features
@section Features

In addition to handling your data just like the original Protracker
would, AdPlug's generic Protracker player has the following extra
features:

@itemize @bullet
@item
Special Arpeggio lists, just like in the SA2 format.
@item
Extendable set of up to 256 note commands.
@item
Up to 16 behaviour changing flags.
@item
Arbitrary numbers of rows, patterns, tracks, instruments and orderlist
entries.
@end itemize

The only current limitation is that it has a maximum 9 voice
polyphony, which isn't really a limitation, since the OPL2 is just 9
voices, anyway.

@node Defaults
@section Defaults

For historical reasons, @code{CmodPlayer} sets defaults to some values
that needn't be initialized by you. These are:

@itemize @bullet
@item
The orderlist is preallocated to 128 entries.
@item
The patterndata is preinitialized to 64 patterns with 9 channels and
64 rows each.
@item
The instruments array is preallocated to 250 instruments.
@end itemize

These are mostly standard Protracker limits. They stem from the
original SA2 defaults, for which this was once the player. Look at the
@code{CmodPlayer} constructor for info on which variables are
involved.

@node Protracker Loaders
@section Protracker Loaders

When you decided to extend the @code{CmodPlayer} class, instead of
writing a whole new player, you do this by writing a loader for
it. This is done very similarily to writing a unique player for
AdPlug. Thus, reading the @ref{Player development} chapter is
recommended for this task, too.

Instead of naming your player class @code{CxxxPlayer}, you should name
it @code{CxxxLoader} or something appropriate if the name is already
taken. You then publicly inherit the @code{CmodPlayer} class and fill
the missing methods with code. These are now:

@example
static CPlayer *factory(Copl *newopl);
bool load(istream &f, const char *filename);
float getrefresh();
std::string gettype();
@end example

Plus maybe some (or all) of the other informational methods, listed in
the @ref{Player development} chapter. Refer also to that chapter to
see what the above methods are about.

@node Designing your Loader
@section Designing your Loader

File validation and initial loading is the same as it would be with
any other player. One speciality is that you have to call
@code{rewind(0)} whenever you completely loaded a valid file. Don't
call it when you just exit your loader because the file was invalid,
etc...

The Protracker player needs at least an orderlist, the patterns and
the instruments to function. Most of the time, you have to convert
these between your file's ordering and @code{CmodPlayer}'s internal
ordering. Look in the file @file{protrack.cpp}, @code{CmodPlayer}'s
actual sources, for a list on how these constructs are ordered
internally.

Also, please look up the @ref{Defaults} section to see if you need to
reallocate any of the defaults.

There are some variables that you have automatically inherited with
your new loader and that you have to set in order to tell the
Protracker player something about your loaded module. These are the
following:

@vtable @code
@item length
The orderlist length. When @code{CmodPlayer}'s orderlist pointer
equals or is bigger than this length, it is automatically wrapped
around to @code{restartpos}.

This variable has no default.

@item trackord
Refer to @ref{Loading Patterns} below on this one.

This variable defaults to @samp{0}.

@item restartpos
The restarting position in the orderlist, when @code{length} is
exceeded.

This variable has no default.

@item activechan
A flag array, telling the player which channels in every pattern are
actually active and to be played. The ordering of this variable is a
bit awkward, so be careful! It is a 16-bit @code{unsigned short},
holding the activeness of a channel in each of its bits,
@strong{starting at the highest order bit}. It also holds values for
16 channels and you can only use the lower 9. So, to set channel 0
active, you have to set bit 15 (counting from bit 0) to @samp{1} and
so on. You only use the upper 9 bits of this variable. Setting the
lower bits will have no effect.

This variable defaults to @samp{0xffff}, meaning all channels are enabled.

@item initspeed
Initial protracker-compatible speed setting.

This variable defaults to @samp{6}, the standard Protracker speed setting.

@item bpm
Initial protracker-compatible bpm (sometimes called tempo) setting.

This variable has no default.

@item flags
Refer to @ref{Special Flags} below.

This variable defaults to @samp{Standard}, which sets standard
Protracker defaults and imposes no specialities.

@item nop
The number of patterns in your module. You don't need to set this
value. If you leave it at @samp{0}, @code{CmodPlayer} will
automatically determine the number of @emph{accessed} patterns (which
in no way need to be the same as the actual number of patterns in your
module) from the orderlist, in the @code{rewind()} method. The value
serves only informational purposes, anyway. It is not needed for the
actual playback. If you think you know better than @code{CmodPlayer},
feel free to set it to something else and @code{CmodPlayer} won't
touch it anymore and display your value instead.

This variable defaults to @samp{0}.
@end vtable

@node Loading Patterns
@section Loading Patterns

AdPlug's Protracker player stores the tracks (or channels, as some may
call them), that make up a pattern, in a way that makes it possible
for you to reorder and reuse them in an easy way. This also makes
storing patterns in the classic way a bit awkward.

If you just want to store your tracks the classic Protracker way
(usually the case), first use the @code{CmodPlayer::init_trackord()}
method to do an initial setup. Then store your tracks in a sequential
manner, counting from 0, in the @code{tracks} array. That is, for the
first 9 channels of your first pattern, use @code{tracks[0..9]}. The
second dimension of this array holds the rows of each channel. For the
next 9 channels, you use @code{tracks[10..19]}, and so on.

If you want to make use of the reorder/reuse feature of the
@code{trackord} array, please refer to the @file{sa2.cpp} source
file. This player utilizes this method.  Basically, the
@code{trackord} array tells the player which track out of the
@code{tracks} array it has to insert for each of the 9 tracks of a
pattern. Thus, the first dimension of this array stands for the
corresponding pattern and the next dimension holds the entries for all
the 9 tracks.

@code{CmodPlayer} orders its note data, in the @code{Tracks} struct,
the following way:

@code{note} holds the note value. A value of @samp{0} means @samp{no
note}. A value of @samp{127} means @samp{key off}. Values from
@samp{1} to @samp{96} are actual notes to be played. Everything else
is ignored. The octaves are encoded with the actual note values. Thus,
notes from @samp{1} to @samp{12} are the 12 halftone-steps of the
first, lowest octave, @samp{13} to @samp{24} are those of the next
lowest octave, and so on. Refer to the source code to see which
frequencies are actually associated with the note values.

@code{inst} holds the instrument to be played with this note. Again, a
@samp{0} value means no instrument is associated with this note and
the last active instrument is taken instead. Otherwise, the instrument
with the number @code{inst} minus 1 is fetched from the @code{inst}
array (it's 0 based).

@code{command} holds the command to be issued with this note. All
available commands are listed in the following table:

@multitable {@code{255--}} {Command descriptionwifuehwuifhw} {Parametersewufwuhwjjhhui} {@code{[0-3,F]iufhu}}
@item Value @tab Command description @tab Parameters @tab Range
@item @code{@ @ 0xy} @tab Arpeggio @tab @code{xy}=1st note,2nd note @tab @code{[0-F]}
@item @code{@ @ 1xx} @tab Frequency slide up @tab @code{xx}=sliding speed @tab @code{[0-FF]}
@item @code{@ @ 2xx} @tab Frequency slide down @tab @code{xx}=sliding speed @tab @code{[0-FF]}
@item @code{@ @ 3xx} @tab Tone portamento @tab @code{xx}=sliding speed @tab @code{[0-FF]}
@item @code{@ @ 4xy} @tab Vibrato @tab @code{xx}=speed,depth @tab @code{[0-F]}
@item @code{@ @ 5xy} @tab Tone portamento & volume slide @tab @code{xy}=vol up|vol down @tab @code{[0-FF]}
@item @code{@ @ 6xy} @tab Vibrato & volume slide @tab @code{xy}=vol up|vol down @tab @code{[0-FF]}
@item @code{@ @ 7xx} @tab Set tempo @tab @code{xx}=new tempo @tab @code{[0-FF]}
@item @code{@ @ 8--} @tab Release sustaining note
@item @code{@ @ 9xy} @tab Set carrier/modulator volume @tab @code{xy}=car vol|mod vol @tab @code{[0-F]}
@item @code{@ 10xy} @tab SA2 volume slide @tab @code{xy}=vol up|vol down @tab @code{[0-F]}
@item @code{@ 11xx} @tab Position jump @tab @code{xx}=new position @tab @code{[0-FF]}
@item @code{@ 12xx} @tab Set carr. & mod. volume @tab @code{xx}=new volume @tab @code{[0-3F]}
@item @code{@ 13xx} @tab Pattern break @tab @code{xx}=new row @tab @code{[0-FF]}
@item @code{@ 14??} @tab Extended command:
@item @code{@ @ @ 0y} @tab Set chip tremolo @tab @code{y}=new depth @tab @code{[0-1]}
@item @code{@ @ @ 1y} @tab Set chip vibrato @tab @code{y}=new depth @tab @code{[0-1]}
@item @code{@ @ @ 3y} @tab Retrig note @tab @code{y}=retrig speed @tab @code{[0-F]}
@item @code{@ @ @ 4y} @tab Fine volume slide up @tab @code{y}=vol up @tab @code{[0-F]}
@item @code{@ @ @ 5y} @tab Fine volume slide down @tab @code{y}=vol down @tab @code{[0-F]}
@item @code{@ @ @ 6y} @tab Fine frequency slide up @tab @code{y}=freq up @tab @code{[0-F]}
@item @code{@ @ @ 7y} @tab Fine frequency slide down @tab @code{y}=freq down @tab @code{[0-F]}
@item @code{@ 15xx} @tab SA2 set speed @tab @code{xx}=new speed @tab @code{[0-FF]}
@item @code{@ 16xy} @tab AMD volume slide @tab @code{xy}=vol up|vol down @tab @code{[0-F]}
@item @code{@ 17xx} @tab Set instrument volume @tab @code{xx}=new volume @tab @code{[0-3F]}
@item @code{@ 18xx} @tab AMD set speed @tab @code{xx}=new speed @tab @code{[0-FF]}
@item @code{@ 19xx} @tab RAD set speed @tab @code{xx}=new speed @tab @code{[0-FF]}
@item @code{@ 20xx} @tab RAD volume slide @tab @code{xx}=vol up/down @tab @code{[0-FF]}
@item @code{@ 21xx} @tab Set modulator volume @tab @code{xx}=new volume @tab @code{[0-3F]}
@item @code{@ 22xx} @tab Set carrier volume @tab @code{xx}=new volume @tab @code{[0-3F]}
@item @code{@ 23xx} @tab Fine frequency slide up @tab @code{xx}=freq up @tab @code{[0-FF]}
@item @code{@ 24xx} @tab Fine frequency slide down @tab @code{xx}=freq down @tab @code{[0-FF]}
@item @code{@ 25xy} @tab Set carrier/modulator waveform @tab @code{xy}=carr wav|mod wav @tab @code{[0-3,F]}
@item @code{@ 26xy} @tab Volume slide @tab @code{xy}=vol up|vol down @tab @code{[0-F]}
@item @code{@ 27xy} @tab Set chip tremolo/vibrato @tab @code{xy}=tr depth|vb depth @tab @code{[0-1]}
@item @code{@ 28xy} @tab DTM frequency slide @tab @code{xy}=frames up|down @tab @code{[0-F]}
@item @code{255--} @tab No operation (NOP)
@end multitable

The @code{param1} and @code{param2} variables hold the command's
parameters. These are command-dependant. Refer to the table above to
see what they do with each of the commands and their value ranges. An
@samp{xx} in the @emph{Parameters} column means that @code{param1} and
@code{param2} form one 2-digit parameter, with @code{param1} being the
leftmost decimal. Otherwise, @samp{x} refers to @code{param1} and
@samp{y} to @code{param2}.

@node Loading Instruments
@section Loading Instruments

For the instrument data, @code{CmodPlayer} stores it in the
@code{inst[].data[]} array, in the following way:

@multitable {Index} {Modulator} {Amp Mod / Vib / EG type / Key Scaling / Multiple} {@samp{0x00}}
@item Index @tab Operator @tab Description @tab OPL2
@item 0 @tab Channel @tab Feedback strength / Connection type @tab @samp{0xc0}
@item 1 @tab Modulator @tab Amp Mod / Vib / EG type / Key Scaling / Multiple @tab @samp{0x20}
@item 2	@tab Carrier @tab Amp Mod / Vib / EG type / Key Scaling / Multiple @tab @samp{0x23}
@item 3 @tab Modulator @tab Attack Rate / Decay Rate @tab @samp{0x60}
@item 4 @tab Carrier @tab Attack Rate / Decay Rate @tab @samp{0x63}
@item 5 @tab Modulator @tab Sustain Level / Release Rate @tab @samp{0x80}
@item 6 @tab Carrier @tab Sustain Level / Release Rate @tab @samp{0x83}
@item 7 @tab Modulator @tab Wave Select @tab @samp{0xe0}
@item 8 @tab Carrier @tab Wave Select @tab @samp{0xe3}
@item 9 @tab Modulator @tab Key scaling level / Operator output level @tab @samp{0x40}
@item 10 @tab Carrier @tab Key scaling level / Operator output level @tab @samp{0x43}
@end multitable

There are 3 extensions, @code{CmodPlayer} imposes to the standard
instrument data. These are also stored within the @code{inst[]} array.

First, there's the @emph{Special Arpeggio}. This is explained in the
@ref{Special Arpeggio} section, below.

Next we got the @code{slide} variable. This is a pre-slide value that
is always added to the frequency of the note, whenever this instrument
is to be played.

Finally, there's the @code{misc} variable. This is just the holder for
the value of the 0xbd register (i.e. the "drums'n'misc" register) of
the OPL2.

@node Special Flags
@section Special Flags

The @code{flags} variable holds special flags to change the behaviour
of the player. These are:

@table @samp
@item Standard
Act like standard Protracker would. This is the default.

@item Decimal
Command parameters are decimal values, not hexadecimal. For split
parameter commands (i.e. commands with two parameters, like
@samp{0xy}), this has no effect, since decimal values would be from
@samp{0} to @samp{9}, anyway. But commands that take both parameters
as one value (i.e. like @samp{1xx}) now take values from @samp{0} to
@samp{99} and handle them properly (i.e. decimal wrap-around is now at
@samp{9} to @samp{10} and not at @samp{F} to @samp{10}).

@item Faust
Treat the files like @emph{Faust Music Creator} does. This tracker
uses a different volume handling scheme. In standard Protracker, the
volume is computed as follows:

@example
final volume = channel volume = instrument volume
@end example

In @emph{Faust Music Creator}, it is done like this:

@example
final volume = (channel volume + instrument volume) / 2
@end example

@item NoKeyOn
This prevents the OPL2 key off/on toggle on every newly played
note. Some trackers require it that way...
@end table

These flags can be set and unset at any time. To set a flag, just
binary @emph{OR} it with the @code{flags} variable. Use the
@code{enum Flags} data type, defined in the @code{CmodPlayer} class
for this purpose.

@node Special Arpeggio
@section Special Arpeggio

To use the @emph{Special Arpeggio} facility, you have to initalize it
first. Use the @code{init_specialarp()} method for this
purpose. @code{CmodPlayer}'s deconstructor automatically handles the
deinit for you.

The special arpeggio uses the 4 variables @code{arpstart},
@code{arpspeed}, @code{arppos} and @code{arpspdcnt} of the
@code{Instrument} struct.

[TODO: actually explain. Refer to sa2.[cpp,h] and the original SA2 docs in
the meantime. The following table summarizes the special commands.]

@multitable {Value} {Set carr. & mod. volume}
@item Value @tab Command description
@item @samp{252} @tab Set carr. & mod. volume
@item @samp{253} @tab Release sustaining note
@item @samp{254} @tab Arpeggio loop
@item @samp{255} @tab End of special arpeggio
@end multitable

@node Copying
@chapter Copying

Blah.

@node Variable Index
@unnumbered Variable Index

@printindex vr

@shortcontents

@bye
